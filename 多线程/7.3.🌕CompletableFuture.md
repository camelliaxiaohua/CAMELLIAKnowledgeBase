[CompletableFuture使用详解（全网看这一篇就行）_supplyasync-CSDN博客](https://blog.csdn.net/zsx_xiaoxin/article/details/123898171?fromshare=blogdetail&sharetype=blogdetail&sharerId=123898171&sharerefer=PC&sharesource=qq_51665235&sharefrom=from_link)

使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。

从**Java 8**开始引入了`CompletableFuture`，它针对`Future`做了改进，可以传入回调对象，**当异步任务完成或者发生异常时，自动调用回调对象的回调方法。**

## <font style="color:rgb(79, 79, 79);">创建异步任务</font>
### `<font style="color:rgb(79, 79, 79);">supplyAsync</font>`
`<font style="color:rgb(77, 77, 77);">supplyAsync</font>`<font style="color:rgb(77, 77, 77);">是创建带</font>**<font style="color:rgb(77, 77, 77);">有返回值</font>**<font style="color:rgb(77, 77, 77);">的异步任务。它有如下两个方法，一个是使用默认线程池</font>`<font style="color:rgb(77, 77, 77);">ForkJoinPool.commonPool()</font>`<font style="color:rgb(77, 77, 77);">的方法，一个是带有自定义线程池的重载方法。</font>

+ **默认线程池**

```java
// 带返回值异步请求，默认线程池。
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
```

+ **自定义线程池**

```java
// 带返回值的异步请求，可以自定义线程池。
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)	
```

```java
public class SupplyAsyncExample {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        ExecutorService executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
        try{
            CompletableFuture <String> supplyAsync = CompletableFuture.supplyAsync(new CompletableTask(new Random().nextInt(10000000)), executor);
            CompletableFuture<Void> future = supplyAsync.thenAcceptAsync(new Consumer<String>() {
                @Override
                public void accept(String result) {
                    System.out.println(result);
                }
            });
            supplyAsync.exceptionallyAsync(new Function<Throwable, String>() {
                @Override
                public String apply(Throwable throwable) {
                    return "";
                }
            });
            future.join();
            long endTime = System.currentTimeMillis();
            System.out.println("耗时：" + (endTime - startTime) + "ms");
        }catch (Exception e){
            e.printStackTrace();
            executor.shutdownNow();
        }finally {
            executor.shutdown();
        }
    }
}


/**
 * 计算水仙花数的任务
 */
class CompletableTask implements Supplier<String> {

    private Integer number;
    // 构造函数，接受一个整数作为计算范围
    CompletableTask(Integer number){
        this.number = number;
    }

    @Override
    public String get() {
        // 设置当前线程的名字为当前计算范围
        Thread.currentThread().setName(number + "以内的水仙数为：");
        StringBuilder result = new StringBuilder();
        // 遍历所有数字，查找水仙花数
        for (int i = 1; i <= number; i++){
            if (isNarcissisticNumber(i)){
                result.append(i).append("\t"); // 将水仙花数添加到结果中
            }
        }
        // 返回计算结果，包含当前线程名称
        return Thread.currentThread().getName() + result;
    }

    /**
     * 判断一个数字是否为水仙花数
     */
    private boolean isNarcissisticNumber(int number){
        int originalNumber = number;
        int digits = String.valueOf(number).length(); // 计算数字的位数
        int sum = 0;
        // 计算每一位的数字的幂并求和
        while (number > 0){
            int digit = number % 10; // 获取数字的每一位
            sum += Math.pow(digit, digits); // 将该位数字的幂加到总和
            number /= 10; // 移除最后一位
        }
        // 如果总和等于原始数字，则为水仙花数
        return sum == originalNumber;
    }
}

```

### `<font style="color:rgb(79, 79, 79);">runAsync</font>`
`<font style="color:rgb(77, 77, 77);">runAsync</font>`<font style="color:rgb(77, 77, 77);">是创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池</font>`<font style="color:rgb(77, 77, 77);">ForkJoinPool.commonPool()</font>`<font style="color:rgb(77, 77, 77);">的方法，一个是带有自定义线程池的重载方法。</font>

+ **默认线程池**

```java
// 不带返回值的异步请求，默认线程池。
public static CompletableFuture<Void> runAsync(Runnable runnable)
```

+ **自定义线程池**

```java
// 不带返回值的异步请求，可以自定义线程池。
public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
```

```java
public class RunAsyncExample { 
    public static void main(String[] args) {

        ExecutorService executor = new ThreadPoolExecutor(3, 6, 60L, java.util.concurrent.TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());

        try{
            CompletableFuture<Void> future = CompletableFuture.runAsync(new RunAsyncTask(), executor);

            future.join(); 
        }catch (Exception e){ 
            e.printStackTrace(); 
            executor.shutdownNow(); 
        }finally { 
            executor.shutdown(); 
        }
    }
}

class RunAsyncTask implements Runnable { 
    @Override 
    public void run(){ 
        System.out.println("start task");   
    }
}
```



## <font style="color:rgb(64, 64, 64);">获取任务结果</font>
### `get()`
```java
public T get() throws InterruptedException, ExecutionException
```

+ **作用**：阻塞当前线程，直到任务完成并返回结果。
+ **异常**：
    - `InterruptedException`：如果当前线程在等待过程中被中断。
    - `ExecutionException`：如果任务执行过程中抛出了异常。
+ **使用场景**：适用于需要等待任务完成并获取结果的场景。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
String result = future.get(); // 阻塞等待结果
System.out.println(result); // 输出 "Hello"
```

### `get(long timeout, TimeUnit unit)`
```java
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
```

+ **作用**：阻塞当前线程，最多等待指定的时间，如果任务在指定时间内完成则返回结果，否则抛出 `TimeoutException`。
+ **异常**：
    - `InterruptedException`：如果当前线程在等待过程中被中断。
    - `ExecutionException`：如果任务执行过程中抛出了异常。
    - `TimeoutException`：如果任务在指定时间内未完成。
+ **使用场景**：适用于需要限制任务等待时间的场景。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(2000); // 模拟耗时任务
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Hello";
});

try {
    String result = future.get(1, TimeUnit.SECONDS); // 最多等待 1 秒
    System.out.println(result);
} catch (TimeoutException e) {
    System.out.println("任务超时未完成");
}
```

### `join()`
```java
public T join()
```

+ **作用**：阻塞当前线程，直到任务完成并返回结果。如果任务执行过程中抛出了异常，会抛出 `CompletionException`，并将原始异常作为原因。
+ **异常**：`CompletionException`（如果任务执行过程中抛出了异常）。
+ **使用场景**：适用于需要等待任务完成并获取结果的场景，且不需要显式处理 `InterruptedException`。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
String result = future.join(); // 阻塞等待结果
System.out.println(result); // 输出 "Hello"
```

### `getNow(T valueIfAbsent)`
```java
public T getNow(T valueIfAbsent)
```

+ **作用**：如果任务已经完成，则返回任务的结果；否则返回给定的默认值 `valueIfAbsent`。
+ **使用场景**：适用于不需要阻塞等待任务完成的场景，可以立即返回一个默认值。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(2000); // 模拟耗时任务
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Hello";
});

String result = future.getNow("Default Value"); // 如果任务未完成，返回 "Default Value"
System.out.println(result); // 输出 "Default Value"
```

### `complete(T value)`
```java
public boolean complete(T value)
```

+ **作用**：如果**任务尚未完成**，则将其结果设置为给定值 `value`，并**标记任务为完成状态**。
+ **返回值**：如果任务尚未完成并且成功设置了结果，则返回 `true`；如果任务已经完成（无论是正常完成、异常完成，还是已取消），则返回 `false`。
+ **使用场景**：适用于手动控制任务完成的场景。

```java
CompletableFuture<String> future = new CompletableFuture<>();
future.complete("Manual Completion"); // 手动完成任务
System.out.println(future.join()); // 输出 "Manual Completion"
```

### `completeExceptionally(Throwable ex)`
```java
public boolean completeExceptionally(Throwable ex)
```

+ **作用**：如果任务尚未完成，则将其状态标记为异常完成，并将给定异常 `ex` 作为任务的结果。
+ **返回值**：如果任务尚未完成并成功标记为异常完成，则返回 `true`；如果任务已经完成，则返回 `false`。
+ **使用场景**：适用于手动控制任务异常完成的场景。

```java
CompletableFuture<String> future = new CompletableFuture<>();
future.completeExceptionally(new RuntimeException("Task failed")); // 手动标记任务为异常完成

try {
    future.join();
} catch (CompletionException e) {
    System.out.println("任务异常: " + e.getCause().getMessage()); // 输出 "任务异常: Task failed"
}
```



## <font style="color:rgb(79, 79, 79);">异步回调处理</font>
| 方法 | 作用 | 线程执行 | 是否返回新值 |
| --- | --- | --- | --- |
| `thenApply` | 转换结果 | **当前线程** | ✅ |
| `thenApplyAsync` | 转换结果 | **线程池** | ✅ |
| `thenAccept` | 消费结果 | **当前线程** | ❌ |
| `thenAcceptAsync` | 消费结果 | **线程池** | ❌ |
| `thenRun` | 运行新任务（不关心结果） | **当前线程** | ❌ |
| `thenRunAsync` | 运行新任务（不关心结果） | **线程池** | ❌ |
| `whenComplete` | 处理完成（不修改结果） | **当前线程** | ❌ |
| `whenCompleteAsync` | 处理完成（不修改结果） | **线程池** | ❌ |
| `handle` | 处理完成（可修改结果） | **当前线程** | ✅ |
| `handleAsync` | 处理完成（可修改结果） | **线程池** | ✅ |


### `thenApply` 和 `thenApplyAsync`
`thenApply` 和 `thenApplyAsync` 用于在异步任务完成后**继续处理结果**，并**返回一个新的 **`**CompletableFuture**`。

#### `<font style="color:rgb(79, 79, 79);">thenApply</font>`
`thenApply` 是同步操作，它会在当前 `CompletableFuture` 完成时立即对结果进行处理，并返回一个新的 `CompletableFuture`，因此可以链式调用多个操作。这个方法会在当前线程中执行后续的操作，也就是说，它是阻塞的，直到该操作执行完成。

```java
<U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn);
```

+ `T`：当前 `CompletableFuture` 完成时的类型。
+ `U`：返回的新的 `CompletableFuture` 类型。
+ `fn`：用于处理当前结果的函数，它接受当前计算的结果 `T`，并返回一个新的结果 `U`。

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
CompletableFuture<String> result = future.thenApply(value -> "Result: " + value);
result.thenAccept(System.out::println);  // 输出: Result: 5
```

#### `<font style="color:rgb(79, 79, 79);">thenApplyAsync</font>`
`thenApplyAsync` 与 `thenApply` 类似，不同之处在于它是异步执行的。这个方法会将后续操作提交给默认的异步执行器，或者如果你指定了执行器的话，它会使用指定的执行器。

```java
<U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn);
<U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn, Executor executor);
```

+ `T`：当前 `CompletableFuture` 完成时的类型。
+ `U`：返回的新的 `CompletableFuture` 类型。
+ `fn`：用于处理当前结果的函数，它接受当前计算的结果 `T`，并返回一个新的结果 `U`。
+ `executor`（可选）：用于执行操作的线程池。如果未指定，默认使用 `ForkJoinPool.commonPool()`。

```java
Executor executor = Executors.newFixedThreadPool(2);
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
CompletableFuture<String> result = future.thenApplyAsync(value -> "Async Result: " + value, executor);
result.thenAccept(System.out::println);  // 异步执行，输出: Async Result: 5
```

### `thenAccept` 和 `thenAcceptAsync`
`thenAccept` 和 `thenAcceptAsync` 用于在异步任务完成后执行某个动作，消费前一个 `CompletableFuture` 的结果，但**不会返回新值**。

#### `<font style="color:rgb(79, 79, 79);">thenAccept</font>`
`thenAccept` 方法用于消费 `CompletableFuture` 计算的结果，但它不会返回任何结果。你可以在 `thenAccept` 中指定一个 `Consumer` 函数，这个函数会在 `CompletableFuture` 完成后执行。注意，它是同步执行的，即在当前线程中执行。

```java
void thenAccept(Consumer<? super T> action);
```

+ `action`：一个 `Consumer`，用于处理 `CompletableFuture` 完成时的结果。

:::danger
`thenAccept` 会在当前 `CompletableFuture` 完成时被调用，并且会在同一线程中执行。

它不会返回一个新的 `CompletableFuture`，即它只是一个终端操作。

:::

```java
import java.util.concurrent.CompletableFuture; 

public class ThenAcceptExample { 
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenAccept(value -> System.out.println("The result is: " + value));  
        // 输出: The result is: 5
    }
}
```

#### `<font style="color:rgb(79, 79, 79);">thenAcceptAsync</font>`
`thenAcceptAsync` 与 `thenAccept` 类似，也用于处理 `CompletableFuture` 计算的结果，但它是在异步线程中执行的。你可以指定一个线程池（`Executor`）来控制后续操作的执行，或者使用默认线程池。

```java
void thenAcceptAsync(Consumer<? super T> action);
void thenAcceptAsync(Consumer<? super T> action, Executor executor);
```

+ `action`：一个 `Consumer`，用于处理 `CompletableFuture` 完成时的结果。
+ `executor`（可选）：指定一个 `Executor` 来执行异步操作。如果未提供，默认使用 `ForkJoinPool.commonPool()`。

:::danger
`thenAcceptAsync` 是异步执行的，后续的处理会在另一个线程中执行，而不是阻塞当前线程。

与 `thenAccept` 相比，`thenAcceptAsync` 允许你将操作委托给一个线程池来执行，避免主线程的阻塞。

:::

```java
import java.util.concurrent.CompletableFuture; 
import java.util.concurrent.ExecutorService; 
import java.util.concurrent.Executors; 

public class ThenAcceptAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenAcceptAsync(value -> System.out.println("Async Result: " + value), executor);
        // 异步执行，输出: Async Result: 5
        executor.shutdown(); 
    }
}
```

### `<font style="color:rgb(79, 79, 79);">thenRun</font>`<font style="color:rgb(79, 79, 79);">和</font>`<font style="color:rgb(79, 79, 79);">thenRunAsync</font>`
`thenRun` 和 `thenRunAsync`用于在异步任务完成后执行某些操作。不关心前一个任务的结果，执行一个新的任务（`Runnable`），但**不接受参数，也不返回结果**。

#### `thenRun`
`thenRun` 方法用于在 `CompletableFuture` 完成后执行一个没有参数的操作。与 `thenAccept` 相似，`thenRun` 也不会返回任何结果。它是同步执行的，即操作会在当前线程中执行，直到完成。  

```java
CompletableFuture<Void> thenRun(Runnable action); 
```

+ `action`：一个 `Runnable`，它表示在 `CompletableFuture` 完成后执行的操作。

:::danger
`thenRun` 是同步执行的，后续的操作会在当前线程中执行，并且不会返回任何值。

该方法适用于你只关心某个异步任务完成后要做一些额外操作，但不需要使用异步任务的结果。

:::

```java
public class ThenRunExample {  
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenRun(() -> System.out.println("Task Completed!"));  
        // 输出: Task Completed!
    }
}
```

#### `thenRunAsync`
`thenRunAsync` 方法与 `thenRun` 类似，但它是在异步线程中执行的。它会将 `Runnable` 操作提交到一个线程池中去执行，从而避免阻塞当前线程。你还可以指定一个自定义的 `Executor` 来控制操作的执行方式。  

```java
CompletableFuture<Void> thenRunAsync(Runnable action);   
CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);   
```

+ `action`：一个 `Runnable`，表示在 `CompletableFuture` 完成后执行的操作。
+ `executor`（可选）：一个 `Executor`，用于指定在哪个线程池中执行该操作。如果不指定，则使用 `ForkJoinPool.commonPool()` 作为默认线程池。

:::danger
`thenRunAsync` 是异步执行的，后续操作会在独立的线程中执行，避免了当前线程的阻塞。

可以通过 `Executor` 指定任务执行的线程池，这为并发操作提供了更高的灵活性。

:::

```java
public class ThenRunAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenRunAsync(() -> System.out.println("Task Completed Asynchronously!"), executor);
        // 输出: Task Completed Asynchronously!
        executor.shutdown(); 
    }
}
```

### `whenComplete`& `whenCompleteAsync` 
`whenComplete` 和 `whenCompleteAsync` 用于在 `CompletableFuture` 执行完成后进行回调处理，无论是成功还是异常，它们都会执行相应的回调逻辑。 

#### `whenComplete`
`whenComplete` 方法用于在 `CompletableFuture` 执行完成后进行回调处理。无论任务是正常完成还是抛出异常，`whenComplete` 方法都会被执行。它在 **当前线程**（即执行 `CompletableFuture` 任务的线程）中执行。  

```java
CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);
```

`action`：一个 `BiConsumer<T, Throwable>`，接受两个参数：

+ `T`：`CompletableFuture` 任务的计算结果（如果成功）。
+ `Throwable`：如果任务抛出异常，则该参数为异常，否则为 `null`。

:::danger
`whenComplete`**不会改变**`CompletableFuture` 的计算结果，它只是一个回调，不会影响原有的 `CompletableFuture`。

**同步执行**，如果前面的任务已经完成，则 `whenComplete` 也会立即执行。

:::

```java
public class WhenCompleteExample { 
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) { 
                throw new RuntimeException("Something went wrong!"); 
            }
            return 10; 
        });
        future.whenComplete((result, exception) -> { 
            if (exception != null) { 
                System.out.println("Execution failed: " + exception.getMessage()); 
            } else { 
                System.out.println("Execution successful: " + result); 
            }
        });
    }
}
```

#### `whenCompleteAsync`
`whenCompleteAsync` 与 `whenComplete` 的主要区别在于它是 **异步执行的**，即 `whenCompleteAsync` 会将回调逻辑交给 **线程池**（默认是 `ForkJoinPool.commonPool()`），而不会在当前线程执行。

```java
CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);
CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);
```

+ `action`：与 `whenComplete` 相同的 `BiConsumer<T, Throwable>`，用于处理成功或失败的结果。
+ `executor`（可选）：可以传入一个 `Executor` 线程池，让回调任务在指定线程池中执行。

:::color3
`whenCompleteAsync`**不会影响** 原有 `CompletableFuture` 的计算结果，它只是用于在任务完成后执行一些额外的逻辑。

**异步执行**，即使 `CompletableFuture` 任务已经完成，`whenCompleteAsync` 也不会立即执行，而是交给线程池去执行。

:::

```java
public class WhenCompleteAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) { 
                throw new RuntimeException("Something went wrong!"); 
            }
            return 10; 
        });
        future.whenCompleteAsync((result, exception) -> { 
            if (exception != null) { 
                System.out.println("Async Execution failed: " + exception.getMessage());
            } else {  
                System.out.println("Async Execution successful: " + result);
            }
        }, executor);  
        executor.shutdown();  
    }
}
```

### `handle` 和 `handleAsync`
`handle` 和 `handleAsync` 类似 `whenComplete`，但 **可以修改返回值**，不管是否发生异常，都会执行。

#### `handle`  
`handle` 方法用于在 `CompletableFuture` 完成时，处理任务的结果或者异常。与 `whenComplete` 类似，`handle` 也可以处理 `CompletableFuture` 任务的成功结果或者异常，但不同之处在于 `handle` 会返回一个新的 `CompletableFuture`。  

```java
<U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);
```

`fn`：一个 `BiFunction<T, Throwable, U>`，它接受两个参数：

+ `T`：`CompletableFuture` 的计算结果（如果任务成功）。
+ `Throwable`：如果任务失败，`Throwable` 为异常，成功则为 `null`。
+ 返回值 `U` 是你想要返回的新的计算结果。

:::color3
`handle` 会在 `CompletableFuture` 执行完成后执行，且可以同时处理成功结果和异常。

`handle` 会返回一个新的 `CompletableFuture`，可以继续链式调用。

`handle` 不仅能处理成功结果，也能处理异常，并且可以改变返回值（通过返回新的结果）。

:::

```java
public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Something went wrong!");
            }
            return 10;
        });

        CompletableFuture<String> handled = future.handle((result, exception) -> {
            if (exception != null) {
                return "Error: " + exception.getMessage();
            } else {
                return "Success: " + result;
            }
        });
        handled.thenAccept(System.out::println);
    }
}
```

#### `handleAsync`  
`handleAsync` 是 `handle` 的异步版本，表示在任务完成后，回调操作将**在另一个线程**中异步执行。这使得它在不阻塞当前线程的情况下处理任务的结果或异常。与 `handle` 不同，`handleAsync` 的回调逻辑是异步执行的。  

```java
<U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);
<U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);
```

+ `fn`：一个 `BiFunction<T, Throwable, U>`，用于处理结果或异常，和 `handle` 中的 `fn` 一样。
+ `executor`（可选）：一个 `Executor`，用于指定在哪个线程池中执行 `fn` 操作。如果不指定，默认使用 `ForkJoinPool.commonPool()`。

:::color3
`handleAsync` 是异步执行的，它会将回调函数提交给一个线程池执行，而不是阻塞当前线程。

如果没有提供 `executor`，默认使用 `ForkJoinPool.commonPool()` 来执行异步操作。

`handleAsync` 允许你在特定的线程池中执行回调函数，可以更好地控制异步任务的执行环境。

:::

```java
public class HandleAsyncExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Something went wrong!");
            }
            return 10;
        });
        CompletableFuture<String> handled = future.handleAsync((result, exception) -> {
            if (exception != null) {
                return "Error: " + exception.getMessage();
            } else {
                return "Success: " + result;
            }
        }, executor);
        handled.thenAccept(System.out::println);
        executor.shutdown();
    }
}
```

## <font style="color:rgb(79, 79, 79);">多任务组合处理 </font>
### `<font style="color:rgb(79, 79, 79);">thenCombine</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">thenAcceptBoth</font>`<font style="color:rgb(79, 79, 79);">和</font>`<font style="color:rgb(79, 79, 79);">runAfterBoth</font>`
它们主要用于组合两个 `CompletableFuture` 并在两个任务都完成后执行相应的操作。它们的主要区别在于结果的处理方式。

#### `<font style="color:rgb(79, 79, 79);">thenCombine</font>`
当两个 `CompletableFuture` 都完成后，合并它们的结果，并返回一个新的 `CompletableFuture`。

```java
public <U, V> CompletableFuture<V> thenCombine(
    CompletionStage<U> other, 
    BiFunction<? super T, ? super U, ? extends V> fn
)
```

+ 另一个 `CompletableFuture<U>`。
+ 一个 `BiFunction<T, U, R>`，用于合并两个结果并返回一个新的值。

```java
public class ThenCombineExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        CompletableFuture<Integer> resultFuture = future1.thenCombine(future2, (a, b) -> a + b);
        System.out.println(resultFuture.join()); // 输出：30
    }
}
```

#### `<font style="color:rgb(79, 79, 79);">thenAcceptBoth</font>`
合并两个 `CompletableFuture` 的结果，但不返回新的 `CompletableFuture`，仅执行一个 `Consumer` 操作。

```java
public <U> CompletableFuture<Void> thenAcceptBoth(
    CompletionStage<U> other, 
    BiConsumer<? super T, ? super U> action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：一个消费两个 `CompletableFuture` 结果的操作

```java
public class ThenAcceptBothExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        future1.thenAcceptBoth(future2, (a, b) -> 
            System.out.println("Sum: " + (a + b))
        ).join(); // 确保主线程等待
        // 输出: Sum: 30
    }
}
```

#### `<font style="color:rgb(79, 79, 79);">runAfterBoth</font>`
在两个 `CompletableFuture` 完成后执行一个 `Runnable` 任务，但不会使用它们的结果。

```java
public CompletableFuture<Void> runAfterBoth(
    CompletionStage<?> other, 
    Runnable action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：在两个 `CompletableFuture` 完成后执行的 `Runnable` 任务

```java
public class RunAfterBothExample { 
    public static void main(String[] args) {

        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {

            System.out.println("Task 1 completed"); 
        });
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {

            System.out.println("Task 2 completed"); 
        });
        future1.runAfterBoth(future2, () ->  
            System.out.println("Both tasks completed") 
        ).join(); // 确保主线程等待

        // 可能输出：

        // Task 1 completed 
        // Task 2 completed 
        // Both tasks completed 
    }
}
```

| 方法 | 作用 | 结果类型 | 适用场景 |
| --- | --- | --- | --- |
| `thenCombine` | 合并两个 `CompletableFuture`结果并返回新结果 | `CompletableFuture<V>` | 需要返回计算后的新值 |
| `thenAcceptBoth` | 处理两个 `CompletableFuture`结果但不返回新结果 | `CompletableFuture<Void>` | 仅处理结果，无需返回 |
| `runAfterBoth` | 在两个 `CompletableFuture`结束后执行任务，不接收结果 | `CompletableFuture<Void>` | 仅执行任务，无需处理结果 |


### `<font style="color:rgb(79, 79, 79);">applyToEither</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">acceptEither</font>`<font style="color:rgb(79, 79, 79);">和</font>`<font style="color:rgb(79, 79, 79);">runAfterEither</font>`
`applyToEither`、`acceptEither` 和 `runAfterEither` 用于在**两个 **`**CompletableFuture**`** 中最先完成的一个**完成时执行操作。

> `applyToEither`：对**先完成**的结果进行转换，并返回新的 `CompletableFuture`。
>
> `acceptEither`：对**先完成**的结果进行消费，但**不返回结果**。
>
> `runAfterEither`：不使用任何结果，仅在**任意一个完成**时执行 `Runnable` 任务。
>

#### `applyToEither`
使用**最先完成**的 `CompletableFuture` 结果进行计算，并返回一个新的 `CompletableFuture`。

```java
public <U> CompletableFuture<U> applyToEither(
    CompletionStage<? extends T> other, 
    Function<? super T, U> fn
)
```

+ `other`：另一个 `CompletableFuture`
+ `fn`：一个**转换函数**，用于处理最先完成的结果，并返回新的值。

```java
public class ApplyToEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000); // 模拟 1 秒后完成
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500); // 模拟 0.5 秒后完成
            return 20;
        });
        CompletableFuture<Integer> result = future1.applyToEither(future2, value -> value * 2);
        System.out.println(result.join()); // 输出 40（因为 future2 先完成，20 * 2）
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### `<font style="color:rgb(79, 79, 79);">acceptEither</font>`
使用**最先完成**的 `CompletableFuture` 结果执行 `Consumer` 任务，但**不返回结果**。

```java
public CompletableFuture<Void> acceptEither(
    CompletionStage<? extends T> other, 
    Consumer<? super T> action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：用于消费最先完成的 `CompletableFuture` 结果的 `Consumer` 操作。

```java
public class AcceptEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000); // 1 秒后完成
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500); // 0.5 秒后完成
            return 20;
        });
        future1.acceptEither(future2, value -> 
            System.out.println("First completed result: " + value)
        ).join(); // 确保主线程等待
        // 输出: First completed result: 20
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### `runAfterEither`
在**任意一个 **`**CompletableFuture**`** 任务完成**后执行 `Runnable` 任务，不接受结果。

```java
public CompletableFuture<Void> runAfterEither(
    CompletionStage<?> other, 
    Runnable action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：在任意一个 `CompletableFuture` 任务完成后执行的 `Runnable` 任务。

```java
public class RunAfterEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {
            sleep(1000); // 1 秒后完成
            System.out.println("Task 1 completed");
        });
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            sleep(500); // 0.5 秒后完成
            System.out.println("Task 2 completed");
        });
        future1.runAfterEither(future2, () -> 
            System.out.println("One of the tasks has completed")
        ).join(); // 确保主线程等待
        // 可能输出：
        // Task 2 completed
        // One of the tasks has completed
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

| 方法 | 作用 | 结果类型 | 适用场景 |
| --- | --- | --- | --- |
| `applyToEither` | 使用最先完成的 `CompletableFuture`结果计算新值 | `CompletableFuture<U>` | 需要返回新值 |
| `acceptEither` | 使用最先完成的 `CompletableFuture`结果执行操作，不返回值 | `CompletableFuture<Void>` | 仅消费结果，无需返回 |
| `runAfterEither` | 只要有一个 `CompletableFuture`完成，就执行 `Runnable`任务 | `CompletableFuture<Void>` | 仅执行任务，不关心结果 |


### `allOf`和`anyOf`
`allOf`等待**所有**`CompletableFuture` 任务完成后再执行后续操作，`anyOf`**任意一个**`CompletableFuture` 任务完成后就执行后续操作。

#### `allOf`
等待**所有**`CompletableFuture` 任务完成后执行后续操作，但**不会返回结果**。

```java
public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)
```

+ `cfs`：可变参数，表示多个 `CompletableFuture` 任务。

```java
public class AllOfExample {
    public static void main(String[] args) {
        List<CompletableFuture<Integer>> futures = IntStream.range(1, 6)
            .mapToObj(i -> CompletableFuture.supplyAsync(() -> {
                sleep(i * 500);
                System.out.println("Task " + i + " completed");
                return i;
            }))
            .collect(Collectors.toList());
        CompletableFuture<Void> allDoneFuture = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        allDoneFuture.join(); // 等待所有任务完成
        System.out.println("All tasks completed");
        // 获取所有结果
        List<Integer> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
        System.out.println("Results: " + results);
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### `anyOf`
**任意一个**`CompletableFuture` 任务完成后就执行后续操作，并返回该任务的结果。

```java
public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)
```

+ `cfs`：可变参数，表示多个 `CompletableFuture` 任务。

```java
public class AnyOfExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return 20;
        });
        CompletableFuture<Integer> future3 = CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return 30;
        });
        CompletableFuture<Object> firstCompleted = CompletableFuture.anyOf(future1, future2, future3);
        System.out.println("First completed result: " + firstCompleted.join());
        // 可能输出：First completed result: 20（因为 future2 先完成）
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```



